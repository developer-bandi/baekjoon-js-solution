# 1. 아이디어

계단을 오를수 있는 모든 경우의 수를 계산하게되면, 이전 계산 값에서 2배씩 늘어나기 때문에, 계산된 수에서 가장 큰수만을 이용해 다음 항을 계산하는 방식으로 해야 시간초과가 발생하지 않습니다.

문제는 간단한데, 계단의 상태는 총 세가지가 될수 있습니다. 이전 계단을 뛰어넘은 상태, 이전계단을 밟은상태, 이전과 그이전 계단을 밟은 상태 입니다. 다음 계단의 차례가 왔을때, 이전계단을 뛰어넘은 상태가 되려면, 이전계단을 밟았거나, 이전과 그이전 계단을 밟은 상태여야합니다. 이전계단을 밟은 상태가 되려면 이전계단을 뛰어넘은 상태가 되어야하고, 이전과 그이전 계단을 밟은 상태가 되려면 이전 계단을 밟은 상태가 되어야합니다. 두번째와 세번째 경우는 한가지 이므로 그대로 대입하고, 첫번째는 경우가 두개이므로 이중 큰값을 택해 다음항을 계속해서 계산하면 됩니다.

# 2. 소스코드

```javascript
const input = require("fs")
  .readFileSync("/dev/stdin")
  .toString()
  .trim()
  .split("\n")
  .map(Number);

let dp = [0, input[1], 0];

for (let i = 2; i < input.length; i++) {
  const cur = input[i];
  dp = [Math.max(dp[1], dp[2]), dp[0] + cur, dp[1] + cur];
}

console.log(Math.max(dp[1], dp[2]));
```
