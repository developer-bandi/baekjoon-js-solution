# 1. 문제

https://www.acmicpc.net/problem/2606

# 2. 아이디어

그래프를 탐색하여 연결된 정점을 탐색하는 문제이므로, dfs bfs중 어떤것을 사용하여도 상관없다. 다만 bfs가 약간 빠르기때문에 bfs를 사용하였다.

# 3. 소스코드

```javascript
const fs = require("fs");
const input = fs.readFileSync("/dev/stdin").toString().trim().split("\n");
const [N, M] = input.shift().split(" ").map(Number);
const list = input.map((row) => {
  return row.split("").map(Number);
});

function BFS() {
  list[0][0] = 0;
  const queue = [[0, 0]];
  let floor = 1;
  out: while (queue.length > 0) {
    floor++;
    const queueLength = queue.length;
    for (let i = 0; i < queueLength; i++) {
      const visitNum = queue.shift();
      if (visitNum[0] !== 0 && list[visitNum[0] - 1][visitNum[1]] === 1) {
        if (visitNum[0] - 1 === N - 1 && visitNum[1] === M - 1) break out;
        queue.push([visitNum[0] - 1, visitNum[1]]);
        list[visitNum[0] - 1][visitNum[1]] = 0;
      }

      if (visitNum[1] !== 0 && list[visitNum[0]][visitNum[1] - 1] === 1) {
        if (visitNum[0] === N - 1 && visitNum[1] - 1 === M - 1) break out;
        queue.push([visitNum[0], visitNum[1] - 1]);
        list[visitNum[0]][visitNum[1] - 1] = 0;
      }

      if (visitNum[0] !== N - 1 && list[visitNum[0] + 1][visitNum[1]] === 1) {
        if (visitNum[0] + 1 === N - 1 && visitNum[1] === M - 1) break out;
        queue.push([visitNum[0] + 1, visitNum[1]]);
        list[visitNum[0] + 1][visitNum[1]] = 0;
      }

      if (visitNum[1] !== M - 1 && list[visitNum[0]][visitNum[1] + 1] === 1) {
        if (visitNum[0] === N - 1 && visitNum[1] + 1 === M - 1) break out;
        queue.push([visitNum[0], visitNum[1] + 1]);
        list[visitNum[0]][visitNum[1] + 1] = 0;
      }
    }
  }
  return floor;
}

console.log(BFS());
```
